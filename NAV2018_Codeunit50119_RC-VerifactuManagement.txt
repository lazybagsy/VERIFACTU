OBJECT Codeunit 50119 RC-Verifactu Management
{
  OBJECT-PROPERTIES
  {
    Date=22/10/25;
    Time=12:00:00;
    Modified=Yes;
    Version List=RC-VERIFACTU;
  }
  PROPERTIES
  {
    SingleInstance=No;
  }
  CODE
  {

    [EventSubscriber(Codeunit,80,OnAfterPostSalesDoc)]
    LOCAL PROCEDURE OnAfterPostSalesDoc@1000000000(VAR SalesHeader@1000000000 : Record 36;VAR GenJnlPostLine@1000000001 : Codeunit 12;SalesShptHdrNo@1000000002 : Code[20];RetRcpHdrNo@1000000003 : Code[20];SalesInvHdrNo@1000000004 : Code[20];SalesCrMemoHdrNo@1000000005 : Code[20];CommitIsSuppressed@1000000006 : Boolean);
    VAR
      SalesInvHeader@1000000007 : Record 112;
      SalesCrMemoHeader@1000000008 : Record 114;
    BEGIN
      IF (SalesInvHdrNo = '') AND (SalesCrMemoHdrNo = '') THEN
        EXIT;

      IF (SalesInvHdrNo <> '') THEN BEGIN
        IF SalesInvHeader.GET(SalesInvHdrNo) THEN
          GenerateVerifactuHash(SalesInvHeader,FALSE);
      END;

      IF SalesCrMemoHdrNo <> '' THEN BEGIN
        IF SalesCrMemoHeader.GET(SalesCrMemoHdrNo) THEN BEGIN
          IF (SalesCrMemoHeader."Corrected Invoice No." <> '') THEN BEGIN
            IF SalesInvHeader.GET(SalesCrMemoHeader."Corrected Invoice No.") THEN
              GenerateVerifactuHash(SalesInvHeader,TRUE);
          END;
        END;
      END;
    END;

    LOCAL PROCEDURE GenerateVerifactuHash@1000000001(VAR SalesInvHeader@1000000000 : Record 112;CorrectedInvoice@1000000009 : Boolean);
    VAR
      HashString@1000000001 : Text;
      HashTestData@1000000002 : Record 50138;
      PreviousHashTestData@1000000006 : Record 50138;
      CompanyInfo@1000000003 : Record 79;
      CuotaTotal@1000000004 : Decimal;
      Timestamp@1000000005 : DateTime;
    BEGIN
      // Crear marca de tiempo unica para usar de forma consistente
      Timestamp := CURRENTDATETIME;

      HashString := BuildHashString(SalesInvHeader,Timestamp,CorrectedInvoice);
      SalesInvHeader."RC-Verifactu Hash" := CalculateSHA256Hash(HashString);
      SalesInvHeader."RC-Verifactu Timestamp" := Timestamp;
      SalesInvHeader.MODIFY;

      // Tambien actualizar tabla 50138 con los datos de la factura
      CompanyInfo.GET;

      // Calcular CalcFields para Importe e Importe IVA incluido
      SalesInvHeader.CALCFIELDS(Amount,"Amount Including VAT");
      CuotaTotal := SalesInvHeader."Amount Including VAT" - SalesInvHeader.Amount;

      // Primero, desactivar cualquier registro anterior con el indicador booleano establecido
      PreviousHashTestData.RESET;
      PreviousHashTestData.SETRANGE("Ult. huella utilizado",TRUE);
      IF PreviousHashTestData.FINDFIRST THEN BEGIN
        PreviousHashTestData."Ult. huella utilizado" := FALSE;
        PreviousHashTestData.MODIFY(TRUE);
      END;

      // Ahora insertar el nuevo registro con una variable limpia
      HashTestData.INIT;
      HashTestData.IDEmisorFactura := CompanyInfo."VAT Registration No.";
      HashTestData.NumSerieFactura := SalesInvHeader."No.";
      HashTestData.FechaExpedicionFactura := SalesInvHeader."Posting Date";
      IF CorrectedInvoice THEN
        HashTestData.TipoFactura := 'R1'
      ELSE
        HashTestData.TipoFactura := 'F1';
      HashTestData.CuotaTotal := CuotaTotal;
      HashTestData.ImporteTotal := SalesInvHeader."Amount Including VAT";
      HashTestData.Huella := SalesInvHeader."RC-Verifactu Hash";
      HashTestData.FechaHoraHusoGenRegistro := Timestamp;
      HashTestData."Ult. huella utilizado" := TRUE;  // Establecer a true en insercion
      HashTestData.INSERT(TRUE);
    END;

    LOCAL PROCEDURE BuildHashString@1000000002(SalesInvHeader@1000000000 : Record 112;Timestamp@1000000001 : DateTime;CorrectedInvoice@1000000010 : Boolean) HashString : Text;
    VAR
      CompanyInfo@1000000002 : Record 79;
      PreviousInvoice@1000000003 : Record 112;
      CuotaTotal@1000000004 : Decimal;
      TipoFactura@1000000005 : Text;
    BEGIN
      CompanyInfo.GET;

      // Calcular CalcFields para Importe e Importe IVA incluido
      SalesInvHeader.CALCFIELDS(Amount,"Amount Including VAT");

      CuotaTotal := SalesInvHeader."Amount Including VAT" - SalesInvHeader.Amount;

      // Establecer TipoFactura segun tipo de documento
      IF CorrectedInvoice THEN
        TipoFactura := 'R1' // Factura rectificativa
      ELSE
        TipoFactura := 'F1'; // Valor por defecto para factura est√°ndar

      // Solo verificar encadenamiento de hash de factura anterior si no es factura rectificativa
      IF NOT CorrectedInvoice THEN BEGIN
        // Verificar si existe una factura anterior con hash (para encadenamiento de hash)
        // Encontrar factura anterior basada en ordenacion de No Serie
        PreviousInvoice.RESET;
        PreviousInvoice.SETCURRENTKEY("No. Series","Posting Date");
        PreviousInvoice.SETRANGE("No. Series",SalesInvHeader."No. Series");
        PreviousInvoice.SETFILTER("RC-Verifactu Hash",'<>%1','');
        PreviousInvoice.SETFILTER("Posting Date",'..%1',SalesInvHeader."Posting Date");
        PreviousInvoice.SETFILTER("No.",'<%1',SalesInvHeader."No.");

        IF PreviousInvoice.FINDLAST THEN
          HashString := 'IDEmisorFactura=' + CompanyInfo."VAT Registration No." +
                        '&NumSerieFactura=' + SalesInvHeader."No." +
                        '&FechaExpedicionFactura=' + FormatDate(SalesInvHeader."Posting Date") +
                        '&TipoFactura=' + TipoFactura +
                        '&CuotaTotal=' + FormatDecimal(CuotaTotal) +
                        '&ImporteTotal=' + FormatDecimal(SalesInvHeader."Amount Including VAT") +
                        '&Huella=' + PreviousInvoice."RC-Verifactu Hash" +
                        '&FechaHoraHusoGenRegistro=' + FormatDateTime(Timestamp)
        ELSE
          HashString := 'IDEmisorFactura=' + CompanyInfo."VAT Registration No." +
                        '&NumSerieFactura=' + SalesInvHeader."No." +
                        '&FechaExpedicionFactura=' + FormatDate(SalesInvHeader."Posting Date") +
                        '&TipoFactura=' + TipoFactura +
                        '&CuotaTotal=' + FormatDecimal(CuotaTotal) +
                        '&ImporteTotal=' + FormatDecimal(SalesInvHeader."Amount Including VAT") +
                        '&Huella=' +
                        '&FechaHoraHusoGenRegistro=' + FormatDateTime(Timestamp);
      END ELSE BEGIN
        // Para facturas rectificativas, usar hash de factura actual
        HashString := '&IDEmisorFacturaAnulada=' + CompanyInfo."VAT Registration No." +
                      '&NumSerieFacturaAnulada=' + SalesInvHeader."No." +
                      '&FechaExpedicionFacturaAnulada=' + FormatDate(SalesInvHeader."Posting Date") +
                      '&Huella=' + SalesInvHeader."RC-Verifactu Hash" +
                      '&FechaHoraHusoGenRegistro=' + FormatDateTime(Timestamp);
      END;
    END;

    LOCAL PROCEDURE FormatDate@1000000003(Value@1000000000 : Date) : Text;
    BEGIN
      EXIT(FORMAT(Value,0,'<Day,2>-<Month,2>-<Year4>'));
    END;

    LOCAL PROCEDURE FormatDateTime@1000000004(Value@1000000000 : DateTime) : Text;
    BEGIN
      EXIT(FORMAT(Value,0,'<Year4>-<Month,2>-<Day,2>T<Hours24,2>:<Minutes,2>:<Seconds,2>+01:00'));
    END;

    LOCAL PROCEDURE FormatDecimal@1000000005(Value@1000000000 : Decimal) : Text;
    VAR
      DecimalString@1000000001 : Text;
    BEGIN
      DecimalString := FORMAT(Value,0,'<Precision,2:2><Standard Format,9>');
      DecimalString := CONVERTSTR(DecimalString,',','.');
      DecimalString := DELCHR(DecimalString,'=',' ');
      EXIT(DecimalString);
    END;

    LOCAL PROCEDURE EscapeXmlText@1000000020(InputText@1000000000 : Text) : Text;
    VAR
      EscapedText@1000000001 : Text;
      Position@1000000002 : Integer;
    BEGIN
      // Escapar caracteres especiales XML para evitar errores de codificacion
      // En NAV 2018, necesitamos usar reemplazo de cadenas en lugar de CONVERTSTR para cadenas de longitud diferente
      EscapedText := InputText;
      
      // Reemplazar & primero (debe hacerse primero para evitar doble escape)
      WHILE STRPOS(EscapedText,'&') > 0 DO BEGIN
        Position := STRPOS(EscapedText,'&');
        EscapedText := COPYSTR(EscapedText,1,Position-1) + '&amp;' + COPYSTR(EscapedText,Position+1);
      END;
      
      // Reemplazar <
      WHILE STRPOS(EscapedText,'<') > 0 DO BEGIN
        Position := STRPOS(EscapedText,'<');
        EscapedText := COPYSTR(EscapedText,1,Position-1) + '&lt;' + COPYSTR(EscapedText,Position+1);
      END;
      
      // Reemplazar >
      WHILE STRPOS(EscapedText,'>') > 0 DO BEGIN
        Position := STRPOS(EscapedText,'>');
        EscapedText := COPYSTR(EscapedText,1,Position-1) + '&gt;' + COPYSTR(EscapedText,Position+1);
      END;
      
      // Reemplazar "
      WHILE STRPOS(EscapedText,'"') > 0 DO BEGIN
        Position := STRPOS(EscapedText,'"');
        EscapedText := COPYSTR(EscapedText,1,Position-1) + '&quot;' + COPYSTR(EscapedText,Position+1);
      END;
      
      // Reemplazar ' (comilla simple)
      WHILE STRPOS(EscapedText,'''') > 0 DO BEGIN
        Position := STRPOS(EscapedText,'''');
        EscapedText := COPYSTR(EscapedText,1,Position-1) + '&apos;' + COPYSTR(EscapedText,Position+1);
      END;
      
      // Eliminar cualquier caracter no imprimible que pueda causar problemas de codificacion
      EscapedText := DELCHR(EscapedText,'=',DELCHR(EscapedText,'=',' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~'));
      
      EXIT(EscapedText);
    END;

    LOCAL PROCEDURE CalculateSHA256Hash@1000000006(InputString@1000000000 : Text) HashValue : Text;
    VAR
      CryptoMgmt@1000000001 : Codeunit 1266;
    BEGIN
      HashValue := CryptoMgmt.GenerateHash(InputString,2);
    END;

    PROCEDURE GenerateSignedVerifactuXML@1000000007(SalesInvHeader@1000000000 : Record 112;VAR SignedXMLText@1000000001 : Text) : Boolean;
    VAR
      XmlText@1000000002 : Text;
      Success@1000000003 : Boolean;
    BEGIN
      // Generar el documento XML base
      IF NOT CreateVerifactuXMLDocument(SalesInvHeader,XmlText) THEN
        EXIT(FALSE);

      // Aplicar firma digital XAdES
      Success := ApplyXAdESSignature(XmlText,SignedXMLText);

      EXIT(Success);
    END;

    LOCAL PROCEDURE CreateVerifactuXMLDocument@1000000008(SalesInvHeader@1000000000 : Record 112;VAR XmlText@1000000001 : Text) : Boolean;
    VAR
      CompanyInfo@1000000002 : Record 79;
      Customer@1000000003 : Record 18;
      CuotaTotal@1000000004 : Decimal;
      Timestamp@1000000005 : DateTime;
      PreviousHashTestData@1000000006 : Record 50138;
      PreviousHash@1000000007 : Text;
      NamespaceUri@1000000008 : Text;
    BEGIN
      CompanyInfo.GET;
      SalesInvHeader.CALCFIELDS(Amount,"Amount Including VAT");
      CuotaTotal := SalesInvHeader."Amount Including VAT" - SalesInvHeader.Amount;
      Timestamp := SalesInvHeader."RC-Verifactu Timestamp";
      IF Timestamp = 0DT THEN
        Timestamp := CURRENTDATETIME;

      // Obtener hash anterior para encadenamiento
      PreviousHashTestData.RESET;
      PreviousHashTestData.SETRANGE("Ult. huella utilizado",TRUE);
      IF PreviousHashTestData.FINDFIRST AND (PreviousHashTestData.NumSerieFactura <> SalesInvHeader."No.") THEN
        PreviousHash := PreviousHashTestData.Huella
      ELSE
        PreviousHash := '';

      Customer.GET(SalesInvHeader."Sell-to Customer No.");

      // Construir XML como texto (enfoque mas simple)
      NamespaceUri := 'https://www2.agenciatributaria.gob.es/static_files/common/internet/dep/aplicaciones/es/aeat/tike/cont/ws/SuministroInformacion.xsd';

      XmlText := '<?xml version="1.0" encoding="UTF-8"?>' +
                 '<sum1:RegistroAlta xmlns:sum1="' + NamespaceUri + '">' +
                 '<sum1:IDVersion>1.0</sum1:IDVersion>' +
                 '<sum1:IDFactura>' +
                 '<sum1:IDEmisorFactura>' + EscapeXmlText(CompanyInfo."VAT Registration No.") + '</sum1:IDEmisorFactura>' +
                 '<sum1:NumSerieFactura>' + EscapeXmlText(SalesInvHeader."No.") + '</sum1:NumSerieFactura>' +
                 '<sum1:FechaExpedicionFactura>' + FormatDate(SalesInvHeader."Posting Date") + '</sum1:FechaExpedicionFactura>' +
                 '</sum1:IDFactura>' +
                 '<sum1:NombreRazonEmisor>' + EscapeXmlText(CompanyInfo.Name) + '</sum1:NombreRazonEmisor>' +
                 '<sum1:Subsanacion>N</sum1:Subsanacion>' +
                 '<sum1:RechazoPrevio>N</sum1:RechazoPrevio>' +
                 '<sum1:TipoFactura>F1</sum1:TipoFactura>' +
                 '<sum1:TipoRectificativa/>' +
                 '<sum1:FacturasRectificadas/>' +
                 '<sum1:FacturasSustituidas/>' +
                 '<sum1:ImporteRectificacion/>' +
                 '<sum1:FechaOperacion>' + FormatDate(SalesInvHeader."Posting Date") + '</sum1:FechaOperacion>' +
                 '<sum1:DescripcionOperacion>Venta de mercancias</sum1:DescripcionOperacion>' +
                 '<sum1:Destinatarios>' +
                 '<sum1:IDDestinatario>' +
                 '<sum1:NombreRazonDestinatario>' + EscapeXmlText(Customer.Name) + '</sum1:NombreRazonDestinatario>' +
                 '<sum1:NIFDestinatario>' + EscapeXmlText(Customer."VAT Registration No.") + '</sum1:NIFDestinatario>' +
                 '</sum1:IDDestinatario>' +
                 '</sum1:Destinatarios>' +
                 BuildDesgloseXML(SalesInvHeader) +
                 '<sum1:CuotaTotal>' + FormatDecimal(CuotaTotal) + '</sum1:CuotaTotal>' +
                 '<sum1:ImporteTotal>' + FormatDecimal(SalesInvHeader."Amount Including VAT") + '</sum1:ImporteTotal>';

      // Agregar encadenamiento si existe hash anterior
      IF PreviousHash <> '' THEN
        XmlText := XmlText + '<sum1:Encadenamiento>' +
                   '<sum1:RegistroAnterior>' +
                   '<sum1:IDEmisorFactura>' + EscapeXmlText(PreviousHashTestData.IDEmisorFactura) + '</sum1:IDEmisorFactura>' +
                   '<sum1:NumSerieFactura>' + EscapeXmlText(PreviousHashTestData.NumSerieFactura) + '</sum1:NumSerieFactura>' +
                   '<sum1:FechaExpedicionFactura>' + FormatDate(PreviousHashTestData.FechaExpedicionFactura) + '</sum1:FechaExpedicionFactura>' +
                   '<sum1:Huella>' + PreviousHash + '</sum1:Huella>' +
                   '</sum1:RegistroAnterior>' +
                   '</sum1:Encadenamiento>';

      XmlText := XmlText + '<sum1:SistemaInformatico>' +
                 '<sum1:NombreRazon>' + EscapeXmlText(CompanyInfo.Name) + '</sum1:NombreRazon>' +
                 '<sum1:NIF>' + EscapeXmlText(CompanyInfo."VAT Registration No.") + '</sum1:NIF>' +
                 '<sum1:NombreSistemaInformatico>Microsoft Dynamics NAV 2018</sum1:NombreSistemaInformatico>' +
                 '<sum1:IdSistemaInformatico>NAV001</sum1:IdSistemaInformatico>' +
                 '<sum1:Version>1.0</sum1:Version>' +
                 '<sum1:NumeroInstalacion>001</sum1:NumeroInstalacion>' +
                 '<sum1:TipoUsoPosibleSoloVerifactu>S</sum1:TipoUsoPosibleSoloVerifactu>' +
                 '<sum1:TipoUsoPosibleMultiOT>N</sum1:TipoUsoPosibleMultiOT>' +
                 '<sum1:IndicadorMultiplesOT>N</sum1:IndicadorMultiplesOT>' +
                 '</sum1:SistemaInformatico>' +
                 '<sum1:FechaHoraHusoGenRegistro>' + FormatDateTime(Timestamp) + '</sum1:FechaHoraHusoGenRegistro>' +
                 '<sum1:TipoHuella>01</sum1:TipoHuella>' +
                 '<sum1:Huella>' + SalesInvHeader."RC-Verifactu Hash" + '</sum1:Huella>' +
                 '</sum1:RegistroAlta>';

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE BuildDesgloseXML@1000000009(SalesInvHeader@1000000000 : Record 112) : Text;
    VAR
      SalesInvLine@1000000001 : Record 113;
      BaseImponible@1000000002 : Decimal;
      TipoImpositivo@1000000003 : Decimal;
      CuotaImpuesto@1000000004 : Decimal;
      DesgloseXML@1000000005 : Text;
    BEGIN
      // Obtener detalles de IVA de las lineas de factura
      SalesInvLine.RESET;
      SalesInvLine.SETRANGE("Document No.",SalesInvHeader."No.");
      SalesInvLine.SETFILTER("VAT %",'>0');

      IF SalesInvLine.FINDSET THEN BEGIN
        REPEAT
          BaseImponible := BaseImponible + SalesInvLine.Amount;
          TipoImpositivo := SalesInvLine."VAT %";
          CuotaImpuesto := CuotaImpuesto + (SalesInvLine."Amount Including VAT" - SalesInvLine.Amount);
        UNTIL SalesInvLine.NEXT = 0;

        DesgloseXML := '<sum1:Desglose>' +
                      '<sum1:DetalleDesglose>' +
                      '<sum1:Impuesto>01</sum1:Impuesto>' +
                      '<sum1:ClaveRegimen>01</sum1:ClaveRegimen>' +
                      '<sum1:CalificacionOperacion>S1</sum1:CalificacionOperacion>' +
                      '<sum1:TipoImpositivo>' + FormatDecimal(TipoImpositivo) + '</sum1:TipoImpositivo>' +
                      '<sum1:BaseImponibleOImporteSujeto>' + FormatDecimal(BaseImponible) + '</sum1:BaseImponibleOImporteSujeto>' +
                      '<sum1:CuotaRepercutida>' + FormatDecimal(CuotaImpuesto) + '</sum1:CuotaRepercutida>' +
                      '</sum1:DetalleDesglose>' +
                      '</sum1:Desglose>';
      END ELSE BEGIN
        DesgloseXML := '<sum1:Desglose>' +
                      '<sum1:DetalleDesglose>' +
                      '<sum1:Impuesto>01</sum1:Impuesto>' +
                      '<sum1:ClaveRegimen>01</sum1:ClaveRegimen>' +
                      '<sum1:CalificacionOperacion>S1</sum1:CalificacionOperacion>' +
                      '<sum1:TipoImpositivo>0.00</sum1:TipoImpositivo>' +
                      '<sum1:BaseImponibleOImporteSujeto>' + FormatDecimal(SalesInvHeader.Amount) + '</sum1:BaseImponibleOImporteSujeto>' +
                      '<sum1:CuotaRepercutida>0.00</sum1:CuotaRepercutida>' +
                      '</sum1:DetalleDesglose>' +
                      '</sum1:Desglose>';
      END;

      EXIT(DesgloseXML);
    END;

    LOCAL PROCEDURE ApplyXAdESSignature@1000000010(VAR UnsignedXML@1000000000 : Text;VAR SignedXMLText@1000000001 : Text) : Boolean;
    VAR
      SignaturePlaceholder@1000000002 : Text;
      CloseTag@1000000003 : Text;
      Position@1000000004 : Integer;
    BEGIN
      // En una implementacion real, necesitaria:
      // 1. Obtener el certificado digital de Gestion de Certificados
      // 2. Aplicar firma XAdES-EPES usando biblioteca o servicio externo
      // 3. Por ahora, simularemos este proceso

      // TODO: Implementar firma digital XAdES real
      // Esto requeriria integracion con:
      // - Almacen de certificados digitales (Windows Certificate Store o archivos PKCS#12)
      // - Biblioteca de firma XAdES (biblioteca .NET externa o servicio web)
      // - Autoridad de sellado de tiempo (TSA) para sellos de tiempo cualificados

      // Para demostracion, devolver el XML sin firmar con marcador de posicion de firma
      SignedXMLText := UnsignedXML;

      // Agregar marcador de posicion de firma antes de etiqueta de cierre
      CloseTag := '</sum1:RegistroAlta>';
      SignaturePlaceholder := GetXAdESSignaturePlaceholder;
      Position := STRPOS(SignedXMLText,CloseTag);
      IF Position > 0 THEN BEGIN
        SignedXMLText := COPYSTR(SignedXMLText,1,Position - 1) + SignaturePlaceholder + COPYSTR(SignedXMLText,Position);
      END;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetXAdESSignaturePlaceholder@1000000011() : Text;
    VAR
      SigningTime@1000000000 : Text;
    BEGIN
      // Formatear tiempo de firma correctamente para evitar problemas de codificacion
      SigningTime := FORMAT(CURRENTDATETIME,0,'<Year4>-<Month,2>-<Day,2>T<Hours24,2>:<Minutes,2>:<Seconds,2>Z');
      
      // Este es un marcador de posicion para la estructura de firma XAdES real
      // En una implementacion real, esto seria generado por el proceso de firma
      EXIT('<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">' +
           '<ds:SignedInfo>' +
           '<ds:CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/>' +
           '<ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>' +
           '<ds:Reference URI="">' +
           '<ds:Transforms>' +
           '<ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>' +
           '</ds:Transforms>' +
           '<ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>' +
           '<ds:DigestValue>PLACEHOLDER_DIGEST_VALUE</ds:DigestValue>' +
           '</ds:Reference>' +
           '</ds:SignedInfo>' +
           '<ds:SignatureValue>PLACEHOLDER_SIGNATURE_VALUE</ds:SignatureValue>' +
           '<ds:KeyInfo>' +
           '<ds:X509Data>' +
           '<ds:X509Certificate>PLACEHOLDER_CERTIFICATE</ds:X509Certificate>' +
           '</ds:X509Data>' +
           '</ds:KeyInfo>' +
           '<xades:QualifyingProperties xmlns:xades="http://uri.etsi.org/01903/v1.3.2#" Target="#signature">' +
           '<xades:SignedProperties>' +
           '<xades:SignedSignatureProperties>' +
           '<xades:SigningTime>' + SigningTime + '</xades:SigningTime>' +
           '</xades:SignedSignatureProperties>' +
           '</xades:SignedProperties>' +
           '</xades:QualifyingProperties>' +
           '</ds:Signature>');
    END;

    PROCEDURE ExportSignedVerifactuXML@1000000012(SalesInvHeader@1000000000 : Record 112);
    VAR
      SignedXML@1000000001 : Text;
      TempFile@1000000002 : File;
      FileName@1000000003 : Text;
      FilePath@1000000004 : Text;
      OutStr@1000000005 : OutStream;
    BEGIN
      IF NOT GenerateSignedVerifactuXML(SalesInvHeader,SignedXML) THEN BEGIN
        MESSAGE('Error al generar XML firmado para factura %1',SalesInvHeader."No.");
        EXIT;
      END;

      // Crear archivo para exportar
      FileName := STRSUBSTNO('Verifactu_%1_%2.xml',SalesInvHeader."No.",FORMAT(CURRENTDATETIME,0,'<Year4><Month,2><Day,2>_<Hours24,2><Minutes,2><Seconds,2>'));
      FilePath := TEMPORARYPATH + FileName;

      TempFile.CREATE(FilePath);
      TempFile.CREATEOUTSTREAM(OutStr);
      OutStr.WRITETEXT(SignedXML);
      TempFile.CLOSE;

      // En NAV 2018, normalmente usariamos DOWNLOAD o mostrar la ruta del archivo
      MESSAGE('Archivo XML firmado creado: %1',FilePath);
      HYPERLINK(FilePath);
    END;

    BEGIN
    END.
  }
}

